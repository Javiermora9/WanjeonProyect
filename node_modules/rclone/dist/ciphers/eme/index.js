"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Encrypt = Encrypt;
exports.Decrypt = Decrypt;
// Javascript port of https://github.com/rfjakob/eme/blob/master/eme.go by rfjakob
// EME is a wide-block encryption mode developed by Halevi and Rogaway.
var DirectionEncrypt = 0;
var DirectionDecrypt = 1;

function multByTwo(out, input) {
  if (input.length !== 16) {
    throw new Error('Invalid length');
  }

  var last = input[0];
  out[0] = 2 * input[0] & 0xff;

  if (input[15] >= 128) {
    out[0] ^= 135;
  }

  for (var j = 1; j < 16; j++) {
    var tmp = input[j];
    out[j] = 2 * input[j] & 0xff;

    if (last >= 128) {
      out[j] = out[j] + 1 & 0xff;
    }

    last = tmp;
  }
}

function xorBlocks(out, in1, in2) {
  if (in1.length !== in2.length && in2.length !== out.length) {
    throw new Error('Length must all match');
  }

  for (var i = 0; i < in1.length; i++) {
    out[i] = in1[i] ^ in2[i];
  }
}

function tabulateL(bc, m) {
  var Li = bc.encrypt([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
  var LTable = new Array(m);

  for (var i = 0; i < m; i++) {
    multByTwo(Li, Li);
    LTable[i] = Li.slice();
  }

  return LTable;
}

function aesTransform(src, direction, bc) {
  if (direction === DirectionEncrypt) {
    return bc.encrypt(src);
  } else if (direction === DirectionDecrypt) {
    var rs = bc.decrypt(src);
    return rs;
  }
}

function Transform(bc, tweak, inputData, direction) {
  // In the paper, the tweak is just called "T". Call it the same here to
  // make following the paper easy.
  var T = tweak; // in bytes
  // In the paper, the plaintext data is called "P" and the ciphertext is
  // called "C". Because encryption and decryption are virtually indentical,
  // we share the code and always call the input data "P" and the output data
  // "C", regardless of the direction.

  var P = inputData; // in bytes

  if (T.length !== 16) {
    throw new Error('Tweak must be 16 bytes long');
  }

  if (P.length % 16 !== 0) {
    throw new Error('Input Data must be a multiple of 16 long');
  }

  var m = P.length / 16;

  if (m === 0 || m > 128) {
    throw new Error('EME operates on 1 to 128 block-cipher blocks, you passed ' + m);
  } // Result


  var C = new Uint8Array(P.length); // in bytes

  var LTable = tabulateL(bc, m); // in bytes

  var PPj = new Uint8Array(16); // in bytes

  for (var j = 0; j < m; j++) {
    var Pj = P.slice(j * 16, (j + 1) * 16);
    /* PPj = 2**(j-1)*L xor Pj */

    xorBlocks(PPj, Pj, LTable[j]);
    /* PPPj = AESenc(K; PPj) */

    C.set(aesTransform(PPj, direction, bc), j * 16);
  }
  /* MP =(xorSum PPPj) xor T */


  var MP = new Uint8Array(16);
  xorBlocks(MP, C.subarray(0, 16), T);

  for (var _j = 1; _j < m; _j++) {
    xorBlocks(MP, MP, C.subarray(_j * 16, (_j + 1) * 16));
  }
  /* MC = AESenc(K; MP) */


  var MC = aesTransform(MP, direction, bc);
  /* M = MP xor MC */

  var M = new Uint8Array(16);
  xorBlocks(M, MP, MC);
  var CCCj = new Uint8Array(16);

  for (var _j2 = 1; _j2 < m; _j2++) {
    multByTwo(M, M);
    /* CCCj = 2**(j-1)*M xor PPPj */

    xorBlocks(CCCj, C.subarray(_j2 * 16, (_j2 + 1) * 16), M);
    C.set(CCCj, _j2 * 16);
  }
  /* CCC1 = (xorSum CCCj) xor T xor MC */


  var CCC1 = new Uint8Array(16);
  xorBlocks(CCC1, MC, T);

  for (var _j3 = 1; _j3 < m; _j3++) {
    xorBlocks(CCC1, CCC1, C.subarray(_j3 * 16, (_j3 + 1) * 16));
  }

  C.set(CCC1, 0);

  for (var _j4 = 0; _j4 < m; _j4++) {
    /* CCj = AES-enc(K; CCCj) */
    C.set(aesTransform(C.subarray(_j4 * 16, (_j4 + 1) * 16), direction, bc), _j4 * 16);
    var tmp = C.subarray(_j4 * 16, (_j4 + 1) * 16);
    /* Cj = 2**(j-1)*L xor CCj */

    xorBlocks(tmp, tmp, LTable[_j4]);
    C.set(tmp, _j4 * 16);
  }

  return C;
}

function Encrypt(bc, tweak, data) {
  return Transform(bc, tweak, data, DirectionEncrypt);
}

function Decrypt(bc, tweak, data) {
  return Transform(bc, tweak, data, DirectionDecrypt);
}