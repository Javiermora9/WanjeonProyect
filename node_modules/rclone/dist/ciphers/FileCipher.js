"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _tweetnacl = _interopRequireDefault(require("tweetnacl"));

var _through = _interopRequireDefault(require("through2"));

var _PushStream = _interopRequireDefault(require("./PushStream"));

var _constants = require("../constants");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var secretbox = _tweetnacl["default"].secretbox;

function FileCipher() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      dataKey = _ref.dataKey;

  if (dataKey === undefined) {
    throw new Error('dataKey must be specified');
  }

  function createReadStreamFactory(createReadStream) {
    return createReadStreamFactoryInternal(createReadStream, dataKey);
  }

  function createReadStream(createReadStream, opts) {
    return createReadStreamFactory(createReadStream)(opts);
  }

  return {
    createReadStream: createReadStream,
    createReadStreamFactory: createReadStreamFactory,
    calculateDecryptedSize: calculateDecryptedSize
  };
}

FileCipher.blockSize = _constants.blockSize;
var _default = FileCipher;
exports["default"] = _default;

function createReadStreamFactoryInternal(getEncryptedStream, key, factOpts) {
  var blockMulitples = factOpts && factOpts.blockMulitples || 16;
  var noncePromise = loadNonce(getEncryptedStream); // Decrypted Stream

  return function (opts) {
    var start = opts && opts.start || 0;
    var blockOffset = Math.floor(start / _constants.blockDataSize);
    var offsetInBlock = start % _constants.blockDataSize;
    var offset = _constants.fileHeaderSize + blockOffset * _constants.blockSize; // The Encrytped stream must be read

    var encrytpedStream = getEncryptedStream({
      start: offset,
      chunkSize: _constants.blockSize * blockMulitples // default 16;

    });
    return new _PushStream["default"](function (next) {
      noncePromise.then(function (initalNonce) {
        // Ensure that initalNonce will not be modfied
        var nonce = initalNonce.slice(); // Advance the nonce to the blockOffset

        incrementNonceBy(nonce, blockOffset);
        encrytpedStream // Create a decryptor for this key and nonce
        .pipe(createCipher(key, nonce)).on('data', function (data) {
          if (offsetInBlock !== 0) {
            data = data.subarray(offsetInBlock);
            offsetInBlock = 0;
          }

          next(null, data);
        }).on('error', function (err) {
          next(err, null);
        }).on('end', function () {
          next(null, null);
        });
      })["catch"](function (err) {
        next(err, null);
      });
    });
  };
}

function loadNonce(getEncryptedStream, key) {
  return new Promise(function (resolve, reject) {
    var stream = getEncryptedStream({
      start: 0,
      end: _constants.fileHeaderSize,
      chunkSize: _constants.fileHeaderSize
    }).once('data', function (data) {
      var magic = data.subarray(0, _constants.fileMagicSize).reduce(function (acc, i) {
        return acc + String.fromCharCode(i);
      }, ''); // Test if this is a valid rClone file

      if (magic !== _constants.fileMagic) {
        reject(new Error('Magic is wrong'));
      }

      var initalNonce = data.subarray(_constants.fileMagicSize);
      stream.destroy(); // Resolve

      resolve(initalNonce);
    });
  });
} // Operation on multiples of blockSize chunks


function createCipher(key, nonce) {
  return (0, _through["default"])(function (data, enc, next) {
    // If there is no content we can stop reading
    if (data.length === 0) {
      return next(null, null);
    } // Size of the decrypted data


    var decryptedSize = calculateDecryptedSize(data.length) + _constants.fileHeaderSize;

    var encryptedOffset = 0;
    var decryptedOffset = 0;

    do {
      // Read a encrypted block from the data array
      var end = encryptedOffset + _constants.blockSize;
      var part = data.subarray(encryptedOffset, end); // Decrypt it

      var decrypted = secretbox.open(part, nonce, key);

      if (decrypted == null) {
        return next(new Error('Could not decrypt data'), null);
      } // Advance Nonce


      incrementNonce(nonce); // Align the decrypted data in the data array

      data.set(decrypted, decryptedOffset); // Advance both offsets

      decryptedOffset += _constants.blockDataSize;
      encryptedOffset = end; // Do we need to decrypt more
    } while (decryptedOffset < decryptedSize);

    next(null, data.subarray(0, decryptedSize));
  });
}

function calculateDecryptedSize(size) {
  size = size - _constants.fileHeaderSize;
  var blocks = Math.floor(size / _constants.blockSize);
  var decryptedSize = blocks * _constants.blockDataSize;
  var residue = size % _constants.blockSize;

  if (residue !== 0) {
    residue -= _constants.blockHeaderSize;
  }

  return decryptedSize + residue;
} // This will break for x > 2^53 because Javascript can't
// represent these numbers...


function incrementNonceBy(nonce, x) {
  if (x <= 0) return;
  var carry = 0;

  for (var i = 0; i < 8; i++) {
    var digit = nonce[i];
    var xDigit = x & 0xff;
    x = x >> 8;
    carry = carry + (digit & 0xffff) + (xDigit & 0xffff);
    nonce[i] = carry & 0xff;
    carry = carry >> 8;
  }

  if (carry != 0) {
    incrementNonce(nounce, 8);
  }
}

function incrementNonce(nonce) {
  var i = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

  for (; i < nonce.length; i++) {
    var digit = nonce[i];
    nonce[i] = digit + 1;

    if (nonce[i] >= digit) {
      break;
    }
  }
}